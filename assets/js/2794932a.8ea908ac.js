"use strict";(self.webpackChunknestjs_toolkit_docs=self.webpackChunknestjs_toolkit_docs||[]).push([[7718],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},9258:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"workflow/usecase","title":"Use Case","description":"Medical Prescription Order Workflow with NestJS Workflow & Kafka Integration","source":"@site/docs/workflow/usecase.md","sourceDirName":"workflow","slug":"/workflow/usecase","permalink":"/libraries/docs/workflow/usecase","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"sidebar_label":"Use Case"},"sidebar":"tutorialSidebar","previous":{"title":"Errors & Logging","permalink":"/libraries/docs/workflow/errors"}}');var i=t(4848),s=t(8453);const a={sidebar_position:4,sidebar_label:"Use Case"},o="Use Case",c={},l=[{value:"Medical Prescription Order Workflow with NestJS Workflow &amp; Kafka Integration",id:"medical-prescription-order-workflow-with-nestjs-workflow--kafka-integration",level:2},{value:"Scenario Description",id:"scenario-description",level:2},{value:"Prescription Order States &amp; Events",id:"prescription-order-states--events",level:2},{value:"States",id:"states",level:3},{value:"Events",id:"events",level:3},{value:"Workflow Definition",id:"workflow-definition",level:2},{value:"Additional Actions upon Status Changes",id:"additional-actions-upon-status-changes",level:2},{value:"Actions Class Definition",id:"actions-class-definition",level:3},{value:"Kafka Integration for Event Dispatching",id:"kafka-integration-for-event-dispatching",level:2},{value:"Kafka Consumer (Event Handler)",id:"kafka-consumer-event-handler",level:3},{value:"Kafka Producer (On Status Change Events)",id:"kafka-producer-on-status-change-events",level:3},{value:"Benefits for Architectural Governance",id:"benefits-for-architectural-governance",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"use-case",children:"Use Case"})}),"\n",(0,i.jsx)(n.h2,{id:"medical-prescription-order-workflow-with-nestjs-workflow--kafka-integration",children:"Medical Prescription Order Workflow with NestJS Workflow & Kafka Integration"}),"\n",(0,i.jsx)(n.h2,{id:"scenario-description",children:"Scenario Description"}),"\n",(0,i.jsx)(n.p,{children:"In a healthcare management system, managing prescription orders efficiently is crucial. Each prescription order moves through different statuses from initiation to completion. The application must reliably handle status transitions, trigger specific actions during transitions, communicate with external systems (such as pharmacies and insurance providers), and integrate event-driven architecture through Kafka."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"prescription-order-states--events",children:"Prescription Order States & Events"}),"\n",(0,i.jsx)(n.h3,{id:"states",children:"States"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export enum PrescriptionStatus {\n  Requested = 'requested',        // Initial state when prescription is created\n  Approved = 'approved',          // Doctor has approved the prescription\n  Rejected = 'rejected',          // Doctor rejected the prescription\n  Processing = 'processing',      // Pharmacy is processing the prescription\n  Dispensed = 'dispensed',        // Medication has been dispensed\n  Completed = 'completed',        // Patient received medication\n  Failed = 'failed'               // An issue occurred in dispensing\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export enum PrescriptionEvent {\n  Request = 'prescription.request',\n  Approve = 'prescription.approve',\n  Reject = 'prescription.reject',\n  Process = 'prescription.process',\n  Dispense = 'prescription.dispense',\n  Complete = 'prescription.complete',\n  Fail = 'prescription.fail'\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"workflow-definition",children:"Workflow Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { WorkflowDefinition } from '@jescrich/nestjs-workflow';\n\nexport const prescriptionWorkflowDefinition: WorkflowDefinition<\n  PrescriptionOrder,\n  any,\n  PrescriptionEvent,\n  PrescriptionStatus\n> = {\n  FinalStates: [PrescriptionStatus.Completed, PrescriptionStatus.Rejected, PrescriptionStatus.Failed],\n  IdleStates: Object.values(PrescriptionStatus),\n  FailedState: PrescriptionStatus.Failed,\n  \n  Transitions: [\n    {\n      from: PrescriptionStatus.Requested,\n      to: PrescriptionStatus.Approved,\n      event: PrescriptionEvent.Approve,\n    },\n    {\n      from: PrescriptionStatus.Requested,\n      to: PrescriptionStatus.Rejected,\n      event: PrescriptionEvent.Reject,\n    },\n    {\n      from: PrescriptionStatus.Approved,\n      to: PrescriptionStatus.Processing,\n      event: PrescriptionEvent.Process,\n    },\n    {\n      from: PrescriptionStatus.Processing,\n      to: PrescriptionStatus.Dispensed,\n      event: PrescriptionEvent.Dispense,\n    },\n    {\n      from: PrescriptionStatus.Dispensed,\n      to: PrescriptionStatus.Completed,\n      event: PrescriptionEvent.Complete,\n    },\n    {\n      from: PrescriptionStatus.Processing,\n      to: PrescriptionStatus.Failed,\n      event: PrescriptionEvent.Fail,\n    },\n  ],\n\n  Entity: {\n    new: () => new PrescriptionOrder(),\n    update: async (entity, status) => {\n      entity.status = status;\n      // Persist the status update in DB\n      await prescriptionRepository.save(entity);\n      return entity;\n    },\n    load: async (urn: string) => {\n      // Load entity from DB\n      return await prescriptionRepository.findOne({ urn });\n    },\n    status: (entity) => entity.status,\n    urn: (entity) => entity.urn,\n  },\n};\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"additional-actions-upon-status-changes",children:"Additional Actions upon Status Changes"}),"\n",(0,i.jsx)(n.p,{children:"Implement class-based actions to handle extra logic after transitions, like communicating with third-party services and producing Kafka events."}),"\n",(0,i.jsx)(n.h3,{id:"actions-class-definition",children:"Actions Class Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Injectable } from '@nestjs/common';\nimport { WorkflowAction, OnEvent, OnStatusChanged } from '@jescrich/nestjs-workflow';\nimport { PrescriptionOrder, PrescriptionEvent, PrescriptionStatus } from './prescription.model';\nimport { KafkaProducerService } from './kafka-producer.service';\nimport { PharmacyIntegrationService } from './pharmacy-integration.service';\n\n@Injectable()\n@WorkflowAction()\nexport class PrescriptionActions {\n  constructor(\n    private readonly kafkaService: KafkaProducerService,\n    private readonly pharmacyService: PharmacyIntegrationService,\n  ) {}\n\n  @OnEvent({ event: PrescriptionEvent.Approve })\n  async notifyInsurance({ entity }: { entity: PrescriptionOrder }) {\n    // Notify insurance provider upon prescription approval\n    await thirdPartyInsuranceAPI.notifyApproval(entity);\n    return entity;\n  }\n\n  @OnStatusChanged({ from: PrescriptionStatus.Approved, to: PrescriptionStatus.Processing })\n  async sendToPharmacy({ entity }: { entity: PrescriptionOrder }) {\n    // Send prescription details to pharmacy system\n    await this.pharmacyService.sendPrescription(entity);\n    return entity;\n  }\n\n  @OnStatusChanged({ from: PrescriptionStatus.Processing, to: PrescriptionStatus.Dispensed })\n  async produceDispensedEvent({ entity }: { entity: PrescriptionOrder }) {\n    // Produce Kafka event when prescription is dispensed\n    await this.kafkaService.produce('prescription.dispensed', {\n      urn: entity.urn,\n      patientId: entity.patientId,\n      pharmacyId: entity.pharmacyId,\n      timestamp: new Date(),\n    });\n    return entity;\n  }\n\n  @OnStatusChanged({ from: PrescriptionStatus.Dispensed, to: PrescriptionStatus.Completed })\n  async completeOrder({ entity }: { entity: PrescriptionOrder }) {\n    // Notify patient that prescription is completed\n    await notificationService.notifyPatient(entity.patientId, 'Your prescription is ready for pickup.');\n    return entity;\n  }\n\n  @OnStatusChanged({ from: PrescriptionStatus.Processing, to: PrescriptionStatus.Failed })\n  async handleFailure({ entity }: { entity: PrescriptionOrder }) {\n    // Alert the support team and produce Kafka event\n    await alertingService.alertSupport('Prescription processing failed.', entity);\n    await this.kafkaService.produce('prescription.failed', {\n      urn: entity.urn,\n      reason: 'Pharmacy processing error',\n      timestamp: new Date(),\n    });\n    return entity;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"kafka-integration-for-event-dispatching",children:"Kafka Integration for Event Dispatching"}),"\n",(0,i.jsx)(n.h3,{id:"kafka-consumer-event-handler",children:"Kafka Consumer (Event Handler)"}),"\n",(0,i.jsx)(n.p,{children:"Handle external events (such as approvals from external doctors) via Kafka and emit corresponding workflow events:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class PrescriptionKafkaConsumer {\n  constructor(\n    @Inject('prescriptionWorkflow')\n    private readonly workflow: Workflow<PrescriptionOrder, PrescriptionEvent>,\n  ) {}\n\n  @KafkaListener('prescription.events')\n  async handlePrescriptionEvents(message: KafkaMessage) {\n    const { urn, event, payload } = message.value;\n    await this.workflow.emit({ urn, event, payload });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"kafka-producer-on-status-change-events",children:"Kafka Producer (On Status Change Events)"}),"\n",(0,i.jsx)(n.p,{children:"Produce Kafka events whenever a prescription order changes state:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class KafkaProducerService {\n  constructor(private readonly kafkaProducer: KafkaProducer) {}\n\n  async produce(topic: string, data: Record<string, any>) {\n    await this.kafkaProducer.send({\n      topic,\n      messages: [{ value: JSON.stringify(data) }],\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"benefits-for-architectural-governance",children:"Benefits for Architectural Governance"}),"\n",(0,i.jsx)(n.p,{children:"Adopting the NestJS Workflow and State Machine pattern in the medical prescription domain provides several architectural and operational benefits:"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Clear and Enforced Business Logic:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"All state transitions explicitly defined and enforced by workflow rules."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Maintainable and Auditable Code:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Single source of truth simplifies future updates and debugging."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Integration Friendly:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Structured integration with external parties (insurance, pharmacies) clearly defined within workflow actions."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Event-Driven Scalability:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Kafka integration facilitates loosely-coupled, highly scalable interactions between systems."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Enhanced Reliability:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Controlled transitions prevent invalid states, ensuring system reliability and patient safety."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Compliance and Auditability:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Structured workflows simplify regulatory compliance and auditing by providing clear documentation of permissible states and actions."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"This use case demonstrates how NestJS Workflow can manage complex business scenarios effectively, incorporating third-party integrations and event-driven architecture. The pattern ensures robust state management, better maintainability, strong architectural governance, and ultimately, a more reliable and scalable medical application system."})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);