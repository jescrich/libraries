"use strict";(self.webpackChunknestjs_toolkit_docs=self.webpackChunknestjs_toolkit_docs||[]).push([[412],{6952:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"workflow/errors","title":"Errors Handling and Logging","description":"Robust error handling is integral to workflows and state machines. In the context of NestJS Workflow, the service provides a built-in fallback mechanism to manage errors during state transitions. This mechanism is defined in the workflow definition as a Fallback function:","source":"@site/docs/workflow/errors.md","sourceDirName":"workflow","slug":"/workflow/errors","permalink":"/libraries/docs/workflow/errors","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"sidebar_label":"Errors & Logging"},"sidebar":"tutorialSidebar","previous":{"title":"Why","permalink":"/libraries/docs/workflow/workflows"},"next":{"title":"Use Case","permalink":"/libraries/docs/workflow/usecase"}}');var t=i(4848),r=i(8453);const s={sidebar_position:4,sidebar_label:"Errors & Logging"},a="Errors Handling and Logging",l={},c=[{value:"<strong>Implementing the Fallback Mechanism</strong>",id:"implementing-the-fallback-mechanism",level:3},{value:"<strong>Logging and Error Controls</strong>",id:"logging-and-error-controls",level:2},{value:"<strong>Integration with Monitoring Tools</strong>",id:"integration-with-monitoring-tools",level:2},{value:"<strong>Benefits of AI-Powered Tools</strong>",id:"benefits-of-ai-powered-tools",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"errors-handling-and-logging",children:"Errors Handling and Logging"})}),"\n",(0,t.jsxs)(e.p,{children:["Robust error handling is integral to workflows and state machines. In the context of NestJS Workflow, the service provides a built-in fallback mechanism to manage errors during state transitions. This mechanism is defined in the workflow definition as a ",(0,t.jsx)(e.code,{children:"Fallback"})," function:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"Fallback?: (entity: T, event: Event, payload?: P | T | object | string) => Promise<T>;\n"})}),"\n",(0,t.jsx)(e.p,{children:"This function is invoked when an error occurs during a transition, allowing developers to define custom logic for handling such scenarios."}),"\n",(0,t.jsx)(e.h3,{id:"implementing-the-fallback-mechanism",children:(0,t.jsx)(e.strong,{children:"Implementing the Fallback Mechanism"})}),"\n",(0,t.jsx)(e.p,{children:"To utilize the fallback mechanism, define it within your workflow definition:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"export const prescriptionWorkflowDefinition: WorkflowDefinition<\n  PrescriptionOrder,\n  any,\n  PrescriptionEvent,\n  PrescriptionStatus\n> = {\n  // ... other definitions\n  Fallback: async (entity, event, payload) => {\n    // Custom error handling logic\n    await kafkaService.produce('workflow.failed', {\n      urn: entity.urn,\n      entityType: 'PrescriptionOrder',\n      currentState: entity.status,\n      event,\n      payload,\n      timestamp: new Date(),\n    });\n    // Optionally, update the entity's status to a failed state\n    entity.status = PrescriptionStatus.Failed;\n    return entity;\n  },\n};\n"})}),"\n",(0,t.jsxs)(e.p,{children:["In this example, when an error occurs during a transition, the fallback function sends an event to a Kafka topic (",(0,t.jsx)(e.code,{children:"workflow.failed"}),") with relevant details and updates the entity's status to ",(0,t.jsx)(e.code,{children:"Failed"}),"."]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"logging-and-error-controls",children:(0,t.jsx)(e.strong,{children:"Logging and Error Controls"})}),"\n",(0,t.jsxs)(e.p,{children:["The NestJS Workflow service incorporates logging to monitor state transitions and errors. By default, it uses NestJS's built-in ",(0,t.jsx)(e.code,{children:"Logger"})," service to log significant events, such as the initialization of actions and transitions."]}),"\n",(0,t.jsx)(e.p,{children:"Transtions and states are logged using the URN or ID as the identifier to be used like a correlation-id. Also a correlation id mechanism can be used to track the flow of a request through the workflow."}),"\n",(0,t.jsx)(e.p,{children:"Also a detailed log of transitions and errors can be maintained by adding custom logging within the workflow definition or using NestJS's logging decorators. For instance, you can log the start and end of transitions, the entity's state, and any errors encountered during the process."}),"\n",(0,t.jsx)(e.p,{children:"These logs provide insights into the workflow's configuration and runtime behavior. For enhanced logging capabilities, developers can integrate custom logging services or third-party monitoring tools."}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-monitoring-tools",children:(0,t.jsx)(e.strong,{children:"Integration with Monitoring Tools"})}),"\n",(0,t.jsx)(e.p,{children:"Integrating a log ingestion or monitoring tool with your workflow system offers several advantages:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Comprehensive Visibility:"})," Monitor all stages and transitions of your business processes in real-time."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Proactive Error Detection:"})," Identify and address issues promptly before they escalate."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Performance Analysis:"})," Analyze the performance of workflows to optimize processes and resource utilization."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["For instance, integrating with tools like ",(0,t.jsx)(e.a,{href:"https://blog.appsignal.com/2023/02/22/track-errors-in-your-nestjs-application-with-appsignal.html",children:"AppSignal"})," can provide application performance monitoring, error tracking, and anomaly detection, enhancing the observability of your NestJS application."]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"benefits-of-ai-powered-tools",children:(0,t.jsx)(e.strong,{children:"Benefits of AI-Powered Tools"})}),"\n",(0,t.jsx)(e.p,{children:"Incorporating AI-powered tools into your workflow and monitoring systems can further enhance operational efficiency:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Automated Insights:"})," AI can analyze vast amounts of data to provide actionable insights, helping in decision-making processes."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Predictive Analytics:"})," Anticipate potential issues or bottlenecks in workflows before they occur, allowing for proactive measures."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Enhanced User Experience:"})," AI-driven tools can personalize interactions and streamline processes, improving overall user satisfaction."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["While specific tools like ",(0,t.jsx)(e.a,{href:"https://app.whawit.ai",children:"Whawit.ai"})," are not widely recognized, the general benefits of AI in workflow management and monitoring are substantial. AI can automate routine tasks, provide predictive insights, and enhance the adaptability of systems to changing conditions."]}),"\n",(0,t.jsx)(e.hr,{})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>a});var o=i(6540);const t={},r=o.createContext(t);function s(n){const e=o.useContext(r);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);