"use strict";(self.webpackChunknestjs_toolkit_docs=self.webpackChunknestjs_toolkit_docs||[]).push([[7930],{1730:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"welcome","metadata":{"permalink":"/libraries/blog/welcome","source":"@site/blog/2021-08-26-welcome/index.md","title":"Welcome to @jescrich Libraries","description":"Welcome to the @jescrich libraries documentation site! This is where you\'ll find comprehensive documentation for enterprise-grade NestJS libraries and utilities.","date":"2021-08-26T00:00:00.000Z","tags":[{"inline":false,"label":"NestJS","permalink":"/libraries/blog/tags/nestjs","description":"NestJS framework related posts and tutorials"},{"inline":false,"label":"TypeScript","permalink":"/libraries/blog/tags/typescript","description":"TypeScript development tips and patterns"},{"inline":false,"label":"Enterprise","permalink":"/libraries/blog/tags/enterprise","description":"Enterprise-grade solutions and best practices"}],"readingTime":0.67,"hasTruncateMarker":true,"authors":[{"name":"Jos\xe9 Escrich","title":"Senior Software Engineer & Library Author","url":"https://joseescrich.com","page":{"permalink":"/libraries/blog/authors/jescrich"},"socials":{"linkedin":"https://www.linkedin.com/in/jescrich/","github":"https://github.com/jescrich"},"imageURL":"https://github.com/jescrich.png","key":"jescrich"}],"frontMatter":{"slug":"welcome","title":"Welcome to @jescrich Libraries","authors":["jescrich"],"tags":["nestjs","typescript","enterprise"]},"unlisted":false,"nextItem":{"title":"Interactive Documentation with MDX","permalink":"/libraries/blog/interactive-documentation"}},"content":"Welcome to the @jescrich libraries documentation site! This is where you\'ll find comprehensive documentation for enterprise-grade NestJS libraries and utilities.\\n\\nHere you\'ll discover powerful tools for building robust, scalable applications:\\n\\n\x3c!-- truncate --\x3e\\n\\n## Featured Libraries\\n\\n### NestJS Kafka Client\\nEnterprise-grade Kafka integration with advanced pressure management, intelligent batch processing, and built-in idempotency. Perfect for high-throughput distributed systems.\\n\\n### URN Utilities\\nA powerful, extensible utility for working with Uniform Resource Names (URNs) with support for validation, parsing, transformation, and manipulation.\\n\\n### NestJS Workflow\\nAn intuitive workflow management tool built specifically for NestJS applications, enabling clear definition and execution of complex business processes.\\n\\n## What\'s Next?\\n\\nExplore the documentation for each library to get started with production-ready solutions that will accelerate your development and improve your application\'s reliability.\\n\\n**Stay tuned for more libraries and updates!**"},{"id":"interactive-documentation","metadata":{"permalink":"/libraries/blog/interactive-documentation","source":"@site/blog/2021-08-01-mdx-blog-post.mdx","title":"Interactive Documentation with MDX","description":"Creating interactive documentation helps developers understand complex concepts through hands-on examples. This post demonstrates how to build engaging documentation using MDX.","date":"2021-08-01T00:00:00.000Z","tags":[{"inline":false,"label":"TypeScript","permalink":"/libraries/blog/tags/typescript","description":"TypeScript development tips and patterns"},{"inline":false,"label":"Workflow","permalink":"/libraries/blog/tags/workflow","description":"Workflow management and automation"}],"readingTime":0.685,"hasTruncateMarker":true,"authors":[{"name":"Jos\xe9 Escrich","title":"Senior Software Engineer & Library Author","url":"https://joseescrich.com","page":{"permalink":"/libraries/blog/authors/jescrich"},"socials":{"linkedin":"https://www.linkedin.com/in/jescrich/","github":"https://github.com/jescrich"},"imageURL":"https://github.com/jescrich.png","key":"jescrich"}],"frontMatter":{"slug":"interactive-documentation","title":"Interactive Documentation with MDX","authors":["jescrich"],"tags":["typescript","workflow"]},"unlisted":false,"prevItem":{"title":"Welcome to @jescrich Libraries","permalink":"/libraries/blog/welcome"},"nextItem":{"title":"Kafka Performance Optimization in NestJS Applications","permalink":"/libraries/blog/kafka-performance-optimization"}},"content":"Creating interactive documentation helps developers understand complex concepts through hands-on examples. This post demonstrates how to build engaging documentation using MDX.\\n\\n:::tip\\n\\nInteractive examples make complex library features more accessible to developers.\\n\\n:::\\n\\n{/* truncate */}\\n\\n## Interactive Code Examples\\n\\nHere\'s an interactive example of URN validation:\\n\\n```typescript\\nimport { URN } from \'@jescrich/urn\';\\n\\n// Try different URN formats\\nconst urn = new URN(\'urn:example:resource:123\');\\nconsole.log(urn.isValid()); // true\\n```\\n\\n<button onClick={() => {\\n  const urn = \'urn:example:resource:\' + Math.floor(Math.random() * 1000);\\n  alert(`Generated URN: ${urn}`);\\n}}>Generate Random URN</button>\\n\\n## Benefits of Interactive Documentation\\n\\nInteractive documentation provides several advantages:\\n\\n1. **Immediate Feedback**: Developers can see results instantly\\n2. **Learning by Doing**: Hands-on examples improve understanding\\n3. **Reduced Friction**: No need to set up local environments for testing\\n\\nThis approach is particularly effective for demonstrating library APIs and complex configuration options."},{"id":"kafka-performance-optimization","metadata":{"permalink":"/libraries/blog/kafka-performance-optimization","source":"@site/blog/2019-05-29-long-blog-post.md","title":"Kafka Performance Optimization in NestJS Applications","description":"Optimizing Kafka performance in NestJS applications requires understanding both the framework\'s patterns and Kafka\'s operational characteristics. This comprehensive guide covers advanced optimization techniques.","date":"2019-05-29T00:00:00.000Z","tags":[{"inline":false,"label":"Kafka","permalink":"/libraries/blog/tags/kafka","description":"Apache Kafka integration and best practices"},{"inline":false,"label":"Performance","permalink":"/libraries/blog/tags/performance","description":"Performance optimization and benchmarking"},{"inline":false,"label":"NestJS","permalink":"/libraries/blog/tags/nestjs","description":"NestJS framework related posts and tutorials"}],"readingTime":2.335,"hasTruncateMarker":true,"authors":[{"name":"Jos\xe9 Escrich","title":"Senior Software Engineer & Library Author","url":"https://joseescrich.com","page":{"permalink":"/libraries/blog/authors/jescrich"},"socials":{"linkedin":"https://www.linkedin.com/in/jescrich/","github":"https://github.com/jescrich"},"imageURL":"https://github.com/jescrich.png","key":"jescrich"}],"frontMatter":{"slug":"kafka-performance-optimization","title":"Kafka Performance Optimization in NestJS Applications","authors":["jescrich"],"tags":["kafka","performance","nestjs"]},"unlisted":false,"prevItem":{"title":"Interactive Documentation with MDX","permalink":"/libraries/blog/interactive-documentation"},"nextItem":{"title":"Building Enterprise-Grade NestJS Libraries","permalink":"/libraries/blog/building-enterprise-nestjs-libraries"}},"content":"Optimizing Kafka performance in NestJS applications requires understanding both the framework\'s patterns and Kafka\'s operational characteristics. This comprehensive guide covers advanced optimization techniques.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Understanding Kafka Performance Bottlenecks\\n\\nWhen building high-throughput Kafka consumers in NestJS, several bottlenecks commonly emerge that can severely impact performance and system stability.\\n\\n### Memory Management Issues\\n\\nTraditional Kafka consumers often suffer from memory exhaustion under high load. Messages accumulate faster than they can be processed, leading to out-of-memory errors and system crashes.\\n\\n### Processing Latency\\n\\nSingle-message processing patterns create significant overhead. Each message requires individual database connections, API calls, and processing cycles, limiting overall throughput.\\n\\n### Ordering vs Parallelism Dilemma\\n\\nMaintaining message ordering while achieving high throughput presents a fundamental challenge. Parallel processing breaks ordering guarantees, while sequential processing limits performance.\\n\\n## Advanced Optimization Strategies\\n\\n### Intelligent Batch Processing\\n\\nImplementing smart batching strategies can dramatically improve throughput:\\n\\n```typescript\\n@Consumer(\'high-volume-topic\', {\\n  batch: true,\\n  batchSize: 500,\\n  batchTimeout: 2000,\\n  groupByKey: true,\\n})\\nexport class OptimizedConsumer {\\n  async handleBatch(messages: KafkaMessage[]) {\\n    // Process messages in key-grouped batches\\n    const grouped = this.groupByKey(messages);\\n    await Promise.all(\\n      Object.entries(grouped).map(([key, msgs]) =>\\n        this.processKeyGroup(key, msgs)\\n      )\\n    );\\n  }\\n}\\n```\\n\\n### Backpressure Management\\n\\nImplementing automatic backpressure prevents system overload:\\n\\n- Monitor queue depth and processing times\\n- Automatically pause consumption when capacity is reached\\n- Resume processing when resources become available\\n\\n### Connection Pooling\\n\\nEfficient connection management reduces overhead:\\n\\n- Reuse database connections across batch operations\\n- Implement connection pooling for external APIs\\n- Monitor connection health and implement failover\\n\\n## Real-World Performance Results\\n\\nIn production environments, these optimizations typically deliver:\\n\\n- **3-4x throughput improvement** over single-message processing\\n- **90% reduction in memory usage** through intelligent batching\\n- **Sub-second latency** even at high message volumes\\n- **Zero message loss** with proper error handling\\n\\n## Implementation Best Practices\\n\\n### Monitoring and Observability\\n\\nComprehensive monitoring is essential for maintaining optimal performance:\\n\\n```typescript\\n@Injectable()\\nexport class KafkaMetricsService {\\n  private metrics = {\\n    messagesProcessed: 0,\\n    avgProcessingTime: 0,\\n    errorRate: 0,\\n  };\\n\\n  @Cron(\'0 * * * * *\')\\n  reportMetrics() {\\n    // Send metrics to monitoring system\\n    this.sendToDatadog(this.metrics);\\n  }\\n}\\n```\\n\\n### Error Handling and Recovery\\n\\nRobust error handling ensures system resilience:\\n\\n- Implement dead letter queues for failed messages\\n- Use exponential backoff for transient errors\\n- Provide manual recovery mechanisms for critical failures\\n\\n### Configuration Tuning\\n\\nPerformance optimization requires careful configuration tuning based on your specific use case:\\n\\n- **High-throughput scenarios**: Large batch sizes, higher concurrency\\n- **Low-latency requirements**: Smaller batches, immediate processing\\n- **Memory-constrained environments**: Conservative batch sizes, aggressive garbage collection\\n\\n## Conclusion\\n\\nOptimizing Kafka performance in NestJS applications requires a holistic approach combining intelligent batching, backpressure management, and comprehensive monitoring. The techniques outlined in this guide have been proven in production environments processing millions of messages daily.\\n\\nBy implementing these strategies, you can achieve enterprise-grade performance while maintaining system reliability and developer productivity."},{"id":"building-enterprise-nestjs-libraries","metadata":{"permalink":"/libraries/blog/building-enterprise-nestjs-libraries","source":"@site/blog/2019-05-28-first-blog-post.md","title":"Building Enterprise-Grade NestJS Libraries","description":"Building production-ready NestJS libraries requires careful consideration of performance, reliability, and developer experience. In this post, I\'ll share insights from developing enterprise-grade libraries.","date":"2019-05-28T00:00:00.000Z","tags":[{"inline":false,"label":"NestJS","permalink":"/libraries/blog/tags/nestjs","description":"NestJS framework related posts and tutorials"},{"inline":false,"label":"Enterprise","permalink":"/libraries/blog/tags/enterprise","description":"Enterprise-grade solutions and best practices"},{"inline":false,"label":"TypeScript","permalink":"/libraries/blog/tags/typescript","description":"TypeScript development tips and patterns"}],"readingTime":0.65,"hasTruncateMarker":true,"authors":[{"name":"Jos\xe9 Escrich","title":"Senior Software Engineer & Library Author","url":"https://joseescrich.com","page":{"permalink":"/libraries/blog/authors/jescrich"},"socials":{"linkedin":"https://www.linkedin.com/in/jescrich/","github":"https://github.com/jescrich"},"imageURL":"https://github.com/jescrich.png","key":"jescrich"}],"frontMatter":{"slug":"building-enterprise-nestjs-libraries","title":"Building Enterprise-Grade NestJS Libraries","authors":["jescrich"],"tags":["nestjs","enterprise","typescript"]},"unlisted":false,"prevItem":{"title":"Kafka Performance Optimization in NestJS Applications","permalink":"/libraries/blog/kafka-performance-optimization"}},"content":"Building production-ready NestJS libraries requires careful consideration of performance, reliability, and developer experience. In this post, I\'ll share insights from developing enterprise-grade libraries.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Key Principles\\n\\nWhen building libraries for enterprise use, several principles guide the development process:\\n\\n### 1. Zero-Configuration Defaults\\nLibraries should work out of the box with sensible defaults while allowing customization when needed.\\n\\n### 2. Performance First\\nEvery feature should be designed with performance in mind, especially for high-throughput scenarios.\\n\\n### 3. Developer Experience\\nClear APIs, comprehensive documentation, and helpful error messages make libraries adoption-friendly.\\n\\n### 4. Production Readiness\\nBuilt-in monitoring, health checks, and graceful error handling are essential for enterprise environments.\\n\\nThese principles have guided the development of libraries like the NestJS Kafka Client, which delivers enterprise-grade messaging capabilities with minimal configuration."}]}}')}}]);